import React, { Component } from 'react';
import PropTypes from 'prop-types';

import Canvas from '../Canvas';

class Confetti extends Component {
  static propTypes = {
    width: PropTypes.number.isRequired,
    height: PropTypes.number.isRequired,

    shapes: PropTypes.array,
    numParticles: PropTypes.number,
    emitDuration: PropTypes.number,
    gravity: PropTypes.number,
    spin: PropTypes.number,
    twist: PropTypes.number,
    minSpeed: PropTypes.number,
    maxSpeed: PropTypes.number,
    minScale: PropTypes.number,
    maxScale: PropTypes.number,
    onComplete: PropTypes.func,

    makeItRainOn: PropTypes.oneOf([
      'click',
      'mount', // Not implemented
    ]),
  };

  static defaultProps = {
    // ✂️ Sensible defaults ✂️
  };

  state = {
    particles: [],
  };

  componentDidUpdate(
    prevProps: Props,
    prevState: State
  ) {
    if (
      prevState.particles.length === 0 &&
      this.state.particles.length > 0
    ) {
      this.tick();
    }
  }

  componentWillUnmount() {
    window.cancelAnimationFrame(this.rafId);
  }

  generateParticles = () => {
    let i = 0;
    let newParticles = [];

    while (i < this.props.numParticles) {
      // ✂️ Particle initialization ✂️
      // Includes generating random values
      // for size, speed, spin, twist, etc.
      // Features ~trigonometry~

      newParticles.push(newParticle);

      i++;
    }

    this.setState({
      particles: [
        ...this.state.particles,
        ...newParticles,
      ],
    });
  };

  tick = () => {
    if (this.state.particles.length === 0) {
      return;
    }

    this.rafId = window.requestAnimationFrame(
      () => {
        const particles = this.calculateNextPositionForParticles();

        this.setState(
          { particles },
          this.tick
        );
      }
    );
  };

  calculateNextPositionForParticles = () => {
    const now = Date.now();

    return this.state.particles
      .map(particle => {
        // ✂️ Particle calculations ✂️

        if (particleNotOnScreen) {
          return null;
        } else {
          return updatedParticle;
        }
      })
      .filter(particle => !!particle);
  };

  draw = ctx => {
    const { particles } = this.state;

    ctx.clearRect(0, 0, width, height);

    particles.forEach(particle => {
      ctx.translate(/* ✂️ */);
      ctx.rotate(/* ✂️ */);
      ctx.scale(/* ✂️ */);

      ctx.drawImage(/* ✂️ */);

      ctx.setTransform(1, 0, 0, 1, 0, 0);
    });
  };

  render() {
    const {
      width,
      height,
      makeItRainOn,
    } = this.props;

    if (prefersReducedMotion()) {
      return null;
    }

    return (
      <Canvas
        width={width}
        height={height}
        draw={this.draw}
        onClick={
          makeItRainOn === 'click' &&
          this.generateParticles
        }
      />
    );
  }
}

export default Confetti;
