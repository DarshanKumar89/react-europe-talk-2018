import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Motion, spring } from 'react-motion';

class ChildTransporter extends Component {
  static propTypes = {
    children: PropTypes.node,
    from: PropTypes.object,
    to: PropTypes.object,
    status: PropTypes.oneOf([
      'closed',
      'open',
      'retracted',
    ]),
  };

  state = {
    status: this.props.status,
    position: {
      top: null,
      left: null,
      right: null,
      bottom: null,
      scaleX: 0,
      scaleY: 0,
      translateX: 0,
      translateY: 0,
    },
  };

  componentWillReceiveProps(nextProps) {
    if (
      this.props.status !== nextProps.status
    ) {
      this.handleStatusChange(nextProps);
    }
  }

  handleStatusChange(nextProps) {
    const { from, to, status } = nextProps;

    this.fromRect = from.getBoundingClientRect();
    this.toRect = to.getBoundingClientRect();
    this.childRect = this.childWrapperNode.getBoundingClientRect();

    const initialPositionState = this.getInitialPositionState(
      status
    );

    this.setState(
      {
        position: initialPositionState,
      },
      this.playAnimation
    );
  }

  getInitialPositionState(status) {
    const {
      fromRect,
      toRect,
      childRect,
    } = this;

    if (!fromRect || !toRect || !childRect) {
      throw new Error(
        'Tried to get position without necessary rects!'
      );
    }

    const relativeRect =
      status === 'closed' ? toRect : fromRect;

    const quadrant = this.getQuadrant(
      relativeRect
    );

    const childPosition = this.getChildPosition(
      quadrant,
      relativeRect,
      status
    );

    const {
      translateX,
      translateY,
    } = this.getTranslate(
      status,
      childPosition
    );

    return {
      ...childPosition,
      translateX,
      translateY,
      scaleX: this.state.position.scaleX,
      scaleY: this.state.position.scaleY,
    };
  }

  playAnimation = () => {
    const { status } = this.props;

    let nextStatus;
    if (status === 'open') {
      nextStatus = 'opening';
    } else if (status === 'closed') {
      nextStatus = 'closing';
    } else if (status === 'retracted') {
      nextStatus = 'retracting';
    } else {
      throw new Error(
        '`playAnimation` called at an invalid moment in time'
      );
    }

    this.setState({
      status: nextStatus,
      position: {
        ...this.state.position,
        translateX: 0,
        translateY: 0,
        scaleX:
          nextStatus === 'opening' ? 1 : 0,
        scaleY:
          nextStatus === 'opening' ? 1 : 0,
      },
    });
  };

  finishPlaying = () => {
    const { status } = this.state;

    let restingStatus;
    if (status === 'opening') {
      restingStatus = 'open';
    } else if (status === 'closing') {
      restingStatus = 'closed';
    } else if (status === 'retracting') {
      restingStatus = 'retracted';
    } else {
      return;
    }

    this.setState({ status: restingStatus });
  };

  getQuadrant(targetRect) {
    const {
      windowWidth,
      windowHeight,
    } = this.props;

    // When expanding from something, we want
    // to use its "opposite" corner. Imagine
    // we divide the screen into quadrants:
    //  ___________
    // |  1  |  2  |
    // |-----|-----|
    // |  3  |  4  |
    // ------------

    const windowCenter = {
      x: windowWidth / 2,
      y: windowHeight / 2,
    };

    if (targetRect.centerY < windowCenter.y) {
      // top half, left or right
      return targetRect.centerX <
        windowCenter.x
        ? 1
        : 2;
    } else {
      // bottom half, left or right
      return targetRect.centerX <
        windowCenter.x
        ? 3
        : 4;
    }
  }

  getChildPosition(
    quadrant,
    targetRect,
    status
  ) {
    const { childRect } = this;

    const orientRelativeToCorner =
      status === 'open' ||
      status === 'retracted';

    switch (quadrant) {
      case 1:
        return {
          top: orientRelativeToCorner
            ? targetRect.bottom
            : targetRect.centerY -
              childRect.height / 2,
          left: orientRelativeToCorner
            ? targetRect.right
            : targetRect.centerX -
              childRect.width / 2,
        };
      case 2:
        return {
          top: orientRelativeToCorner
            ? targetRect.bottom
            : targetRect.centerY -
              childRect.height / 2,
          right: orientRelativeToCorner
            ? targetRect.fromBottomRight.left
            : targetRect.fromBottomRight
                .centerX -
              childRect.width / 2,
        };
      case 3:
        return {
          bottom: orientRelativeToCorner
            ? targetRect.fromBottomRight.top
            : targetRect.fromBottomRight
                .centerY -
              childRect.height / 2,
          left: orientRelativeToCorner
            ? targetRect.right
            : targetRect.centerX -
              childRect.width / 2,
        };
      case 4:
        return {
          bottom: orientRelativeToCorner
            ? targetRect.fromBottomRight.top
            : targetRect.fromBottomRight
                .centerY -
              childRect.height / 2,
          right: orientRelativeToCorner
            ? targetRect.fromBottomRight.left
            : targetRect.fromBottomRight
                .centerX -
              childRect.width / 2,
        };
      default:
        throw new Error(
          `Unrecognized quadrant: ${quadrant}`
        );
    }
  }

  getTranslate(status, pendingChildRect) {
    const {
      childRect: currentChildRect,
    } = this;

    if (
      status === 'open' ||
      status === 'retracted'
    ) {
      return { translateX: 0, translateY: 0 };
    }

    const [x, y] = getPositionDelta(
      currentChildRect,
      pendingChildRect
    );
    return { translateX: x, translateY: y };
  }

  render() {
    const {
      children,
      springOpenHorizontal,
      springOpenVertical,
      springCloseHorizontal,
      springCloseVertical,
    } = this.props;
    const { status, position } = this.state;

    const {
      top,
      left,
      right,
      bottom,
      scaleX,
      scaleY,
      translateX,
      translateY,
    } = position;

    const shouldSpringScale = [
      'opening',
      'closing',
      'retracting',
    ].includes(status);

    const shouldSpringTransform =
      status === 'closing';

    return (
      <Motion
        style={{
          scaleX: shouldSpringScale
            ? spring(scaleX)
            : scaleX,
          scaleY: shouldSpringScale
            ? spring(scaleY)
            : scaleY,
          translateX: shouldSpringTransform
            ? spring(translateX)
            : translateX,
          translateY: shouldSpringTransform
            ? spring(translateY)
            : translateY,
        }}
      >
        {({
          scaleX,
          scaleY,
          translateX,
          translateY,
        }) => (
          <div
            ref={node => {
              this.childWrapperNode = node;
            }}
            style={{
              position: 'fixed',
              top,
              left,
              bottom,
              right,
              transform: `
                translate(${translateX}px, ${translateY}px)
                scale(${scaleX}, ${scaleY})
              `,
            }}
          >
            {children}
          </div>
        )}
      </Motion>
    );
  }
}

export default ChildTransporter;
